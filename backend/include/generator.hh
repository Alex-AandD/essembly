#pragma once
#include <vector>
#include <string>
#include <memory>

/* the input of the generator is going to be the AST */
/*  then on the AST we call the visitor, which is going to create an
    unoptimized form of bytecode. The instruction generated by the visitor
    is going to go in the stream vector;
    Then we start optimizing the stream vector
*/

namespace Essembly {

class Instruction;
class BytecodeVisitor;
class DisassembleVisitor;
class Expr;

using u_ptrBVisitor = std::unique_ptr<BytecodeVisitor>;
using u_ptrDisVisitor = std::unique_ptr<DisassembleVisitor>;
using u_ptrExpr = std::unique_ptr<Expr>;

class Generator {
    /* the input is going to be the AST generated by the parser */
    /* then we use the visitor on this AST */
    u_ptrExpr AST;
    u_ptrBVisitor bytecodeVisitor;
    u_ptrDisVisitor disassembleVisitor;
    std::vector<Instruction*> instructions;
public:
    Generator(u_ptrExpr&  AST);
    ~Generator();
public:
    /* here we will call the visit method for every statement */
    void generateBytecode();
    [[nodiscard]] inline std::vector<Instruction*> getInstructions() const noexcept  { return instructions; }
    // TODO: #12 do not repeat code in disassemble functions. create some base function that get's called @Alex-AandD
    void disassemble() const noexcept;
    void disassemble(std::string filename) const noexcept;
};
}